
# Project 4: Gesture Detection

By mounting an MPU6050 on the glove we can read the Roll and Pitch angles in real time and output the corresponding gestures through the serial port, paving the way for later Bluetooth transmission or mecanum-car control.

---

## 1  Attitude-Angle Overview
With only an MPU6050 on the glove, the Yaw (heading) angle drifts, so we read only Roll and Pitch.  
<span style="color:#ff4c41">For complete three-axis angles, add a magnetometer for calibration.</span>  

### Roll (Y-axis)  
Fingers pointing forward; rotate the hand left/right around the palm.

| Angle | Gesture |
|-------|---------|
| 0 °   | Hand level |
| –180 ° | Fully rolled left |
| +180 ° | Fully rolled right |

![img](./index_img/new(69).png)

### Pitch (X-axis)  
Fingers pointing forward; raise/lower the hand around the palm.

| Angle | Gesture |
|-------|---------|
| 0 °   | Hand level |
| –180 ° | Hand raised |
| +180 ° | Hand pressed down |

![img](./index_img/new(70).png)

---

## 2  Example Gesture Ranges  
When the angles fall into the ranges below, you can treat them as the corresponding gestures (feel free to adjust):

1. Level: X and Y both –10 ° ~ 10 °  
2. Roll-left: Y axis –20 ° ~ –90 °  
3. Roll-right: Y axis  20 ° ~  90 °  
4. Raise-up: X axis  20 ° ~  90 °  
5. Press-down: X axis –20 ° ~ –90 °

> Keep Bluetooth disconnected while uploading code; after flashing, open the Serial Monitor to view real-time angles and gesture text.

---

## 3  Full Source Code `lesson_4_1.ino`

```cpp
#include "MPU6050.h"

MPU6050lib mpu;

/* -------- Global Variables -------- */
float aRes, gRes;
int16_t accelCount[3];
int16_t gyroCount[3];
float ax, ay, az;
float gyrox, gyroy, gyroz;
float gyroBias[3]  = {0, 0, 0};
float accelBias[3] = {0, 0, 0};
int16_t tempCount;
float temperature;
float SelfTest[6];
float q[4] = {1.0f, 0.0f, 0.0f, 0.0f};
float pitch, yaw, roll;

float GyroMeasError = PI * (40.0f / 180.0f);      // 40 °/s
float beta = sqrt(3.0f / 4.0f) * GyroMeasError;   // Madgwick parameter
float GyroMeasDrift = PI * (2.0f / 180.0f);       // 2 °/s
float zeta = sqrt(3.0f / 4.0f) * GyroMeasDrift;   // Drift parameter
float deltat = 0.0f;
uint32_t lastUpdate = 0, firstUpdate = 0;
uint32_t Now = 0;

/* -------- Setup -------- */
void setup()
{
  Wire.begin();
  Serial.begin(9600);

  uint8_t c = mpu.readByte(MPU6050_ADDRESS, WHO_AM_I_MPU6050);
  Serial.print("I AM 0x"); Serial.println(c, HEX);

  mpu.settings(AFS_8G, GFS_250DPS);               // temporary range
  if (c == 0x68)                                  // device found
  {
    Serial.println("MPU6050 is online...");
    mpu.MPU6050SelfTest(SelfTest);                // run self-test

    if (SelfTest[0] < 1.0f && SelfTest[1] < 1.0f && SelfTest[2] < 1.0f &&
        SelfTest[3] < 1.0f && SelfTest[4] < 1.0f && SelfTest[5] < 1.0f)
    {
      Serial.println("Self-test passed!");
      mpu.calibrateMPU6050(gyroBias, accelBias);  // bias calibration
      mpu.settings(AFS_2G, GFS_250DPS);           // final range
      mpu.initMPU6050();                          // start data mode
      Serial.println("MPU6050 initialized.");
    }
  }
  else
  {
    Serial.print("Could not connect to MPU6050: 0x");
    Serial.println(c, HEX);
    while (1);                                    // halt
  }
}

/* -------- Main Loop -------- */
void loop()
{
  /* 1) Read IMU data */
  if (mpu.readByte(MPU6050_ADDRESS, INT_STATUS) & 0x01)
  {
    mpu.readAccelData(accelCount);
    aRes = mpu.getAres();
    ax = (float)accelCount[0] * aRes;
    ay = (float)accelCount[1] * aRes;
    az = (float)accelCount[2] * aRes;

    mpu.readGyroData(gyroCount);
    gRes = mpu.getGres();
    gyrox = (float)gyroCount[0] * gRes;
    gyroy = (float)gyroCount[1] * gRes;
    gyroz = (float)gyroCount[2] * gRes;

    tempCount  = mpu.readTempData();
    temperature = ((float)tempCount) / 340.0f + 36.53f;
  }

  /* 2) Madgwick filter */
  Now = micros();
  deltat = (Now - lastUpdate) / 1000000.0f;       // Δt in seconds
  lastUpdate = Now;
  if (lastUpdate - firstUpdate > 10000000UL)      // after 10 s relax β, ζ
  {
    beta = 0.041f;
    zeta = 0.015f;
  }

  gyrox *= PI / 180.0f;
  gyroy *= PI / 180.0f;
  gyroz *= PI / 180.0f;
  MadgwickQuaternionUpdate(ax, ay, az, gyrox, gyroy, gyroz);

  /* 3) Convert to Euler angles */
  pitch = -asin(2.0f * (q[1] * q[3] - q[0] * q[2])) * 180.0f / PI;
  roll  =  atan2(2.0f * (q[0] * q[1] + q[2] * q[3]),
                 q[0]*q[0] - q[1]*q[1] - q[2]*q[2] + q[3]*q[3])
           * 180.0f / PI;

  /* 4) Output gesture text */
  if (abs(pitch) <= 40 && abs(roll) <= 40)
    Serial.println("Gestures:Horizontal");
  else if (pitch <= -40 && pitch >= -90 && abs(roll) <= 40)
    Serial.println("Gestures:Hand to the left");
  else if (pitch >=  40 && pitch <=  90 && abs(roll) <= 40)
    Serial.println("Gestures:Hand to the right");
  else if (roll  <= -40 && roll  >= -90 && abs(pitch) <= 40)
    Serial.println("Gestures:Hand down");
  else if (roll  >=  20 && roll  <=  90 && abs(pitch) <= 40)
    Serial.println("Gestures:Hand up");

  delay(100);                                     // update every 100 ms
}

/* -------- Sebastian Madgwick Quaternion Filter -------- */
void MadgwickQuaternionUpdate(float ax, float ay, float az,
                              float gyrox, float gyroy, float gyroz)
{
  float q1 = q[0], q2 = q[1], q3 = q[2], q4 = q[3];
  float norm;
  float f1, f2, f3;
  float J_11or24, J_12or23, J_13or22, J_14or21, J_32, J_33;
  float qDot1, qDot2, qDot3, qDot4;
  float hatDot1, hatDot2, hatDot3, hatDot4;
  float gerrx, gerry, gerrz, gbiasx, gbiasy, gbiasz;

  float _halfq1 = 0.5f * q1;
  float _halfq2 = 0.5f * q2;
  float _halfq3 = 0.5f * q3;
  float _halfq4 = 0.5f * q4;
  float _2q1 = 2.0f * q1;
  float _2q2 = 2.0f * q2;
  float _2q3 = 2.0f * q3;
  float _2q4 = 2.0f * q4;
  float _2q1q3 = 2.0f * q1 * q3;
  float _2q3q4 = 2.0f * q3 * q4;

  /* Normalize accelerometer */
  norm = sqrt(ax*ax + ay*ay + az*az);
  if (norm == 0.0f) return;
  norm = 1.0f / norm;
  ax *= norm; ay *= norm; az *= norm;

  /* Objective function and Jacobian */
  f1 = _2q2 * q4 - _2q1 * q3 - ax;
  f2 = _2q1 * q2 + _2q3 * q4 - ay;
  f3 = 1.0f - _2q2 * q2 - _2q3 * q3 - az;
  J_11or24 = _2q3;
  J_12or23 = _2q4;
  J_13or22 = _2q1;
  J_14or21 = _2q2;
  J_32 = 2.0f * J_14or21;
  J_33 = 2.0f * J_11or24;

  hatDot1 = J_14or21 * f2 - J_11or24 * f1;
  hatDot2 = J_12or23 * f1 + J_13or22 * f2 - J_32 * f3;
  hatDot3 = J_12or23 * f2 - J_33 * f3 - J_13or22 * f1;
  hatDot4 = J_14or21 * f1 + J_11or24 * f2;

  norm = sqrt(hatDot1*hatDot1 + hatDot2*hatDot2 +
              hatDot3*hatDot3 + hatDot4*hatDot4);
  hatDot1 /= norm; hatDot2 /= norm; hatDot3 /= norm; hatDot4 /= norm;

  /* Estimate and cancel gyroscope drift */
  gerrx = _2q1*hatDot2 - _2q2*hatDot1 - _2q3*hatDot4 + _2q4*hatDot3;
  gerry = _2q1*hatDot3 + _2q2*hatDot4 - _2q3*hatDot1 - _2q4*hatDot2;
  gerrz = _2q1*hatDot4 - _2q2*hatDot3 + _2q3*hatDot2 - _2q4*hatDot1;

  gbiasx += gerrx * deltat * zeta;
  gbiasy += gerry * deltat * zeta;
  gbiasz += gerrz * deltat * zeta;
  gyrox  -= gbiasx;
  gyroy  -= gbiasy;
  gyroz  -= gbiasz;

  /* Integrate quaternion rate and normalize */
  qDot1 = -_halfq2*gyrox - _halfq3*gyroy - _halfq4*gyroz;
  qDot2 =  _halfq1*gyrox + _halfq3*gyroz - _halfq4*gyroy;
  qDot3 =  _halfq1*gyroy - _halfq2*gyroz + _halfq4*gyrox;
  qDot4 =  _halfq1*gyroz + _halfq2*gyroy - _halfq3*gyrox;

  q1 += (qDot1 - beta*hatDot1) * deltat;
  q2 += (qDot2 - beta*hatDot2) * deltat;
  q3 += (qDot3 - beta*hatDot3) * deltat;
  q4 += (qDot4 - beta*hatDot4) * deltat;

  norm = sqrt(q1*q1 + q2*q2 + q3*q3 + q4*q4);
  norm = 1.0f / norm;
  q[0] = q1 * norm;
  q[1] = q2 * norm;
  q[2] = q3 * norm;
  q[3] = q4 * norm;
}
```

---

## Detailed Code Explanation

### 1. Include Library & Create Object
```cpp
#include "MPU6050.h"   // Load the MPU6050 sensor library
MPU6050lib mpu;        // Create an MPU6050 object
```
Prepares for all subsequent MPU6050 read/write operations.

### 2. Global Variable Declarations  
Stores sensor data, intermediate values, and attitude results.

### 3. `setup()` – Initialization  
Initializes I²C and Serial, checks the MPU6050, performs self-test and calibration, then switches to active data mode.

### 4. `loop()` – Main Routine  
1) Acquire accelerometer & gyroscope data.  
2) Fuse the data with the Madgwick algorithm to get orientation.  
3) Convert the quaternion to Euler angles *pitch* and *roll*.  
4) Compare the angles with thresholds and print the gesture text every 100 ms.

### 5. `MadgwickQuaternionUpdate()`  
Mathematical implementation of Sebastian Madgwick’s filter:  
• Normalizes acceleration,  
• Builds the objective function & Jacobian,  
• Compensates gyro drift,  
• Integrates quaternion rate,  
• Normalizes the quaternion for the current hand orientation.
